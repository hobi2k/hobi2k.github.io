---
layout: post
title:  "Style-Bert-VITS2 해부 시리즈 – 텍스트 전처리와 클리너"
date:   2026-01-19 00:10:22 +0900
categories: Style-Bert-VITS2
---

# Style-Bert-VITS2 해부 시리즈 — 텍스트 전처리와 클리너

## 1. 이 편의 목적

Style-Bert-VITS2에서 텍스트는 절대 그대로 모델에 들어가지 않는다.
텍스트는 다음 경로를 반드시 거친다.

```
raw text
 → text cleaner (정규화)
 → G2P (phoneme / tone)
 → token id / embedding
```

이번 편에서는 그중 첫 단계, 즉

- 텍스트 클리너가 정확히 무엇을 하고
- 왜 여기서의 실수가 학습 실패/음질 붕괴로 직결되는지
- 일본어 기준으로 지우면 안 되는 것 / 반드시 지워야 하는 것

을 코드 기준으로 정리한다.

## 2. 텍스트 전처리의 위치

전체 파이프라인 중 텍스트 전처리는 여기다.

```
[filelist]
   |
   v
(raw text)
   |
   v
[Text Cleaner]   ← ★ 이번 편
   |
   v
[G2P / Tone]
   |
   v
[TextEncoder + BERT]
```

중요한 점:

- 클리너는 학습/추론 모두에서 동일하게 적용된다.
- 여기서 텍스트가 달라지면,
  - phoneme이 달라지고
  - duration이 달라지고
  - prosody 전체가 무너진다.

## 3. Style-Bert-VITS2의 텍스트 클리너 개념

Style-Bert-VITS2의 클리너는 “언어학적 해석기”가 아니다.

역할은 단 하나다:

> G2P가 안정적으로 작동하도록 텍스트를 정리한다.

즉,

- 의미를 보존하려고 애쓰지 않는다
- 발음 불가능 / 애매한 기호를 제거하거나 치환한다
- 언어별(G2P별)로 허용 문자 집합을 좁힌다

## 4. 클리너의 입력과 출력

### 입력

- filelist의 마지막 필드에 있는 raw text
- 예:

「……今日は、なんだか静かすぎる気がする。」

### 출력

- G2P로 바로 넘길 정제된 문자열
- 예:

今日は、なんだか静かすぎる気がする。


출력은 여전히 문자열이다.
아직 phoneme도, token id도 아니다.

## 5. 일본어 기준: “지워야 하는 것”과 “지우면 안 되는 것”
### 5.1 반드시 제거(또는 치환)해야 하는 것

아래 요소들은 G2P를 불안정하게 만들거나 바로 에러를 유발한다.


| 유형      | 예시                 | 이유                     |
| ------- | ------------------ | ---------------------- |
| 제어 문자   | `\u200b`, `\ufeff` | 눈에 안 보이지만 tokenizer 파괴 |
| 비표준 괄호  | `《 》 【 】`          | OpenJTalk 계열에서 미지원     |
| 장식 기호   | `★ ☆ ♥ ♪`          | 발음 불가                  |
| 이모지     | 🙂 😢 🔥           | tokenizer/G2P 모두 실패    |
| HTML 잔재 | `&nbsp;`           | 데이터 수집 부산물             |


원칙: “발음할 수 없으면 제거”

### 5.2 절대 지우면 안 되는 것 (일본어 기준)

여기서 실수하면 억양·호흡이 완전히 망가진다.


| 요소        | 예시                | 이유              |
| --------- | ----------------- | --------------- |
| 문장부호      | `。 、 ？ ！`         | 억양/포즈 정보        |
| 장음        | `ー`               | 실제 발음 길이        |
| 반복 기호     | `…` (점 하나로 축약 권장) | 망설임/간           |
| 히라가나/가타카나 | 全部                | G2P 핵심          |
| 한자        | 感情、静か             | OpenJTalk 처리 대상 |

특히 문장부호 제거는 최악의 선택이다.
-> 문장이 “한 호흡”으로 읽히며 prosody 붕괴.

## 6. 괄호 처리의 실제 전략

일본어 음성 데이터에는 이런 텍스트가 매우 흔하다.

影（かげ）の中で、彼女は笑った。

### 잘못된 처리

- 괄호와 내용 전부 삭제
  - 발음 정보 손실

### 권장 처리

- 표면 문자만 유지

影の中で、彼女は笑った。


### 이유:

- 루비(읽기 보조)는 G2P 단계에서 처리하지 않는다
- 발화 텍스트는 “실제 말하는 내용”만 남긴다

## 7. 클리너와 데이터 품질(QC)의 관계

Style-Bert-VITS2에서 텍스트 클리너는
QC(품질 검사)의 1차 필터 역할도 한다.

일반적으로 다음 샘플은 아예 제거 대상이다.

- 문장이 끝나지 않은 텍스트

今日はとても

- 발화가 아닌 메타 텍스트

（息を吸う）
[笑]

- 음성과 명백히 불일치
  - 효과음, 배경 설명만 있는 경우

이 판단을 클리너 단계에서 하지 않으면,
뒤에서 “이상한 음성”으로 돌아온다.

## 8. 학습과 추론에서 “클리너 불일치”가 만드는 문제

아주 흔한 실수:

학습 시 클리너 A
추론 시 클리너 B

이 경우 발생하는 현상:

- 발음은 맞는데 억양이 이상함
- 특정 문장만 길이/속도가 튄다
- 학습 데이터에 없는 기호에서 추론 실패

학습과 추론은 100% 동일한 클리너를 사용해야 한다.

## 9. 이 단계의 입출력 요약

### 입력

- raw text (filelist)

### 출력

- 정제된 텍스트 문자열

아직 생성되는 파일은 없다.
하지만 다음 단계(G2P)의 성공률은 여기서 결정된다.

## 10. 텍스트 전처리는 “하나의 파일”이 아니다

Style-Bert-VITS2에서 텍스트 전처리는 단일 cleaner 함수가 아니라,
언어별로 분산된 모듈 + 공통 인터페이스 구조다.

핵심 결론부터 말하면:

filelist의 text는 `TextProcessor > language-specific cleaner > G2P` 순서로 처리된다.

## 11. 텍스트가 처음으로 잡히는 지점 (엔트리)

```
style_bert_vits2/data_utils.py
```

### 핵심 클래스 / 함수

```
class TextProcessor:
    def get_text(self, text, lang):
        ...
```

이 함수가 filelist의 raw text를 처음으로 받아서 가공한다.

### 호출 위치

- DataLoader가 샘플을 로드할 때
- 학습 시 / 추론 시 모두 동일

즉, 텍스트 전처리의 단일 진입점(entry point)은 TextProcessor.get_text()다.

## 12. TextProcessor 내부 흐름

get_text() 내부 흐름은 대략 다음과 같다.

```
raw text
 └─> language 분기
      └─> language-specific text processing
           └─> G2P
                └─> phoneme / tone / ids
```

즉, TextProcessor는 직접 클리닝을 거의 하지 않는다.
실제 처리는 언어별 NLP 모듈로 위임된다.

## 13. 일본어 텍스트 전처리 담당 모듈

```
style_bert_vits2/nlp/japanese/
```

여기부터가 일본어 전처리의 실질적인 본체다.

## 14. 일본어 텍스트 정규화 & G2P 엔트리

```
style_bert_vits2/nlp/japanese/g2p.py
```

### 핵심 함수

```
def g2p(text: str, use_jp_extra: bool = False):
    ...
```

이 함수가:

- 정제된 텍스트를 입력으로 받아
- phoneme
- tone
- word2ph (있을 경우)

를 생성한다.

일본어에서 “클리너 + G2P”는 사실상 이 파일 하나에 응집돼 있다.

## 15. “클리너”는 어디 있나?

Style-Bert-VITS2에는
cleaners.py 같은 독립적인 text cleaner 파일이 없다.

- 일본어: g2p.py 내부에서 문자 정규화 + 필터링
- 영어/중국어: 각 언어 디렉토리 내부에서 처리

즉, Tacotron 계열처럼 “cleaner 단계 -> G2P 단계”가 분리되어 있지 않다
G2P 함수 안에서 클리닝이 함께 이루어진다

## 16. 일본어 클리닝이 실제로 일어나는 위치

```
style_bert_vits2/nlp/japanese/g2p.py
```

내부에서 다음과 같은 작업들이 일어난다.

- 특수 기호 제거 / 치환
- 읽기 불가능한 문자 필터
- OpenJTalk로 넘기기 전 문자열 정리

즉, “지워야 할 문자 / 남겨야 할 문자” 정책은 전부 여기 들어 있다.

## 17. OpenJTalk 호출 지점

같은 파일 안에서:

```python
import pyopenjtalk
```

그리고 내부에서:

```python
pyopenjtalk.g2p(...)
pyopenjtalk.extract_fullcontext(...)
```

이 호출들이 실제로:

- 히라가나/가타카나/한자를
- 발음 단위(phoneme)와
- 억양 정보(tone)

로 변환한다.

문자열이 음성학 정보로 바뀌는 최초의 지점이다.

## 18. tone / phoneme이 만들어지는 구조

g2p() 함수의 반환값은 대략 다음 형태다.

```python
phones: List[str]
tones: List[int]
word2ph: Optional[List[int]]
```

이 결과는 다시 TextProcessor로 돌아가서

- phoneme vocab -> id 변환
- mask 생성

으로 이어진다.

## 19. 정리: “텍스트 전처리 담당 파일” 정확 요약
일본어 기준, 반드시 알아야 할 파일 3개


| 역할               | 파일                                     |
| ---------------- | -------------------------------------- |
| 텍스트 전처리 엔트리      | `style_bert_vits2/data_utils.py`       |
| 일본어 텍스트 처리 + G2P | `style_bert_vits2/nlp/japanese/g2p.py` |
| OpenJTalk 연동     | (동일 파일 내부)                             |


### 핵심 한 줄 요약

Style-Bert-VITS2에서 텍스트 클리닝은 “독립 단계”가 아니라,
언어별 G2P 모듈 내부에서 수행된다.

참고 자료 
https://github.com/litagin02/Style-Bert-VITS2